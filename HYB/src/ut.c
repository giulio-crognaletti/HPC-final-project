#include "ut.h"
// =============================================================
//  utilities for managing pgm files
//
//  * write_pgm_image
//  * read_pgm_image
//  * swap_image
//
// =============================================================

void write_pgm_image( void *image, int maxval, int xsize, int ysize, const char *image_name)
/*
 * image        : a pointer to the memory region that contains the image
 * maxval       : either 255 or 65536 <- respectively 2^8-1 (1B per pixel) and 2^16-1 (2B per pixel)
 * xsize, ysize : x and y dimensions of the image
 * image_name   : the name of the file to be written
 *
 */
{
  FILE* image_file; 
  image_file = fopen(image_name, "w"); 
  
  // Writing header
  // The header's format is as follows, all in ASCII.
  // "whitespace" is either a blank or a TAB or a CF or a LF
  // - The Magic Number (see below the magic numbers)
  // - the image's width
  // - the height
  // - a white space
  // - the image's height
  // - a whitespace
  // - the maximum color value, which must be between 0 and 65535
  //
  // if he maximum color value is in the range [0-255], then
  // a pixel will be expressed by a single byte; if the maximum is
  // larger than 255, then 2 bytes will be needed for each pixel
  //

  int color_depth = 1 + ( maxval > 255 );

  fprintf(image_file, "P5\n# generated by\n# put here your name\n%d %d\n%d\n", xsize, ysize, maxval);
  
  // Writing file
  fwrite( image, 1, xsize*ysize*color_depth, image_file);  

  fclose(image_file); 
  return ;

  /* ---------------------------------------------------------------
     TYPE    MAGIC NUM     EXTENSION   COLOR RANGE
           ASCII  BINARY
     PBM   P1     P4       .pbm        [0-1]
     PGM   P2     P5       .pgm        [0-255]
     PPM   P3     P6       .ppm        [0-2^16[
  
  ------------------------------------------------------------------ */
}


void read_pgm_image( void **image, int *maxval, int *xsize, int *ysize, const char *image_name)
/*
 * image        : a pointer to the pointer that will contain the image
 * maxval       : a pointer to the int that will store the maximum intensity in the image
 * xsize, ysize : pointers to the x and y sizes
 * image_name   : the name of the file to be read
 *
 */
{
  FILE* image_file; 
  image_file = fopen(image_name, "r"); 

  *image = NULL;
  *xsize = *ysize = *maxval = 0;
  
  char    MagicN[2];
  char   *line = NULL;
  size_t  k, n = 0;
  
  // get the Magic Number
  k = fscanf(image_file, "%2s%*c", MagicN );

  // skip all the comments
  k = getline( &line, &n, image_file);
  while ( (k > 0) && (line[0]=='#') )
    k = getline( &line, &n, image_file);

  if (k > 0)
    {
      k = sscanf(line, "%d%*c%d%*c%d%*c", xsize, ysize, maxval);
      if ( k < 3 )
	fscanf(image_file, "%d%*c", maxval);
    }
  else
    {
      *maxval = -1;         // this is the signal that there was an I/O error
			    // while reading the image header
      free( line );
      return;
    }
  free( line );
  
  int color_depth = 1 + ( *maxval > 255 );
  unsigned int size = *xsize * *ysize * color_depth;
  
  if ( (*image = (char*)malloc( size )) == NULL )
    {
      fclose(image_file);
      *maxval = -2;         // this is the signal that memory was insufficient
      *xsize  = 0;
      *ysize  = 0;
      return;
    }
  
  if ( fread( *image, 1, size, image_file) != size )
    {
      free( image );
      image   = NULL;
      *maxval = -3;         // this is the signal that there was an i/o error
      *xsize  = 0;
      *ysize  = 0;
    }  

  fclose(image_file);
  return;
}


void swap_image( void *image, int xsize, int ysize, int maxval )
/*
 * This routine swaps the endianism of the memory area pointed
 * to by ptr, by blocks of 2 bytes
 *
 */
{
  if ( maxval > 255 )
    {
      // pgm files has the short int written in
      // big endian;
      // here we swap the content of the image from
      // one to another
      //
      unsigned int size = xsize * ysize;
      for ( int i = 0; i < size; i++ )
  	((unsigned short int*)image)[i] = swap(((unsigned short int*)image)[i]);
    }
  return;
}



// =============================================================
//

void * generate_gradient( int maxval, int xsize, int ysize )
/*
 * just and example about how to generate a vertical gradient
 * maxval is either 255 or 65536, xsize and ysize are the
 * x and y dimensions of the image to be generated.
 * The memory region that will contain the image is returned
 * by the function as a void *
 */
{
  char      *cImage;   // the image when a single byte is used for each pixel
  short int *sImage;   // the image when a two bytes are used for each pixel
  void      *ptr;
  
  int minval      = 0; 
  int delta       = (maxval - minval) / ysize;
  
  if(delta < 1 )
    delta = 1;
  
  if( maxval < 256 )
    // generate a gradient with 1 byte of color depth
    {
      cImage = (char*)calloc( xsize*ysize, sizeof(char) );
      unsigned char _maxval = (char)maxval;
      int idx = 0;
      for ( int yy = 0; yy < ysize; yy++ )
	{
	  unsigned char value = minval + yy*delta;
	  for( int xx = 0; xx < xsize; xx++ )
	    cImage[idx++] = (value > _maxval)?_maxval:value;
	}
      ptr = (void*)cImage;
    }
  else
    // generate a gradient with 2 bytes of color depth
    {
      sImage = (unsigned short int*)calloc( xsize*ysize, sizeof(short int) );
      unsigned short int _maxval = swap((unsigned short int)maxval);
      int idx = 0;
      for ( int yy = 0; yy < ysize; yy++ )
	{
	  unsigned short int value  = (short int) (minval+ yy*delta);
	  unsigned short int _value = swap( value );    // swap high and low bytes, the format expect big-endianism

	  for( int xx = 0; xx < xsize; xx++ )
	    sImage[idx++] = (value > maxval)?_maxval:_value;
	}
      ptr = (void*)sImage;	
    }

  return ptr;
}


/*************************************************************************************
* 																MY ROUTINES
**************************************************************************************/

// =============================================================
//  utilities for doing convolution, taking into account the border effect
//
//  * Border_blur
//  * Convolve
//  
//	utilities for managing kernels of convolution
//
//	*uniform_kernel
//	*weighted_kernel
//	*gaussian_kernel
//	*normalize
//
// =============================================================

/*
* KERNEL MANAGEMENT
*/

void uniform_kernel(KTYPE *mat, size_t x, size_t y)
{
	int i, j;
	KTYPE norm = 1.0/(x*y);
	
	for(i = 0; i<x; i++)
		for(j = 0; j<y; j++)	mat[i+x*j] = norm;
		
	return;	
}

void weighted_kernel(KTYPE *mat, size_t x, size_t y, KTYPE f)
{
	int i, j;
	KTYPE w = (1.0-f)/(x*y-1.0);
	
	for(i = 0; i<x; i++)
		for(j = 0; j<y; j++)	mat[i+x*j] = (i-x/2 || j-y/2)?w:f;
	
	return;
}

void gaussian_kernel(KTYPE *mat, size_t x, size_t y, KTYPE sigma_sq)
//builds a kernel using a gaussian function centered in the middle of the matrix 
{
	int i, j;
	int xc = x/2, yc = y/2;
	
	KTYPE norm=0;
	for(i = 0; i<x; i++)
		for(j = 0; j<y; j++)	
		{ 
			mat[i+x*j] = exp(((i-xc)*(i-xc)+(j-yc)*(j-yc))/(-2*sigma_sq));
			norm+=mat[i+x*j];
		}
	
		norm = 1.0/norm;
		
	for(i = 0; i<x; i++)
		for(j = 0; j<y; j++)	mat[i+x*j] *= norm;
		
	return;
}

KTYPE *normalize(void *kimage,size_t x,size_t y,int maxval)
{
	KTYPE norm,*ret = (KTYPE *)malloc(sizeof(KTYPE)*x*y);
	int i,j;
	KTYPE sum=0;
	for(j=0;j<y;j++)
		for(i=0;i<x;i++) sum += maxval>255 ? ((unsigned short int *)kimage)[i+x*j] : ((char *)kimage)[i+x*j];
		
	norm = 1.0/sum;
	
	for(j=0;j<y;j++)
		for(i=0;i<x;i++) ret[i+x*j] = maxval>255 ? ((unsigned short int *)kimage)[i+x*j]*norm : ((char *)kimage)[i+x*j]*norm;
	return ret;
}


/*
* CONVOLUTION and SWAPPING
*/

void OMP_swap_image( void *image, int xsize, int ysize, int maxval )
/*
 * This routine swaps the endianism of the memory area pointed
 * to by ptr, by blocks of 2 bytes
 *
 * !! This function contains orphaned OMP directives -> to be used in a parallel region
 */
{
  if ( maxval > 255 )
    {
      // pgm files has the short int written in
      // big endian;
      // here we swap the content of the image from
      // one to another
      //
      unsigned int size = xsize * ysize;
      #pragma omp for
      for ( int i = 0; i < size; i++ )
  	((unsigned short int*)image)[i] = swap(((unsigned short int*)image)[i]);
    }
  return;
}

void Border_blur(unsigned short int *image, unsigned short int *blurred ,int xsize, int ysize, int i, int j, KTYPE *convolution_matrix, int xconv, int yconv ,int sx, int sy, int lines_up, int lines_down)
/*
* Does the blurring for points on the border, i.e. for the values of (i,j) such that the dimensions of the kernel centered here exceeds the dimensions of the image itself 
*/
{

	//indices representing the position wrt the kernel
	int l,m; 
		
	//normalization constant (actually its inverse) -> it must be evaluated again since some parts of the kernel are not used here, hence the rest is not properly normalized anymore
	KTYPE norm = 0;
	
	//stores the partial sums for the final value of the blurred image in (i,j) : here used instead of the natural choice of the blurred matrix itself to avoid lossy conversions from
	//floating point to unsigned integer -> this loss is minimized by doing it only once at the end. 
	KTYPE buffer = 0;
	
	/*here (and int the initializarion of the for loop) the limits of kernel positions are evaluated: this evaluation takes into account the presence of some additional lines of image
	* above and below the blurred one, to match the presence of halo layers, but at the same time makes sure that this does not yield an illegal index, in this case smaller than 0 or 
	* bigger than the size of the image -> this could happen in the pathological case in which the halo layer is very thick (thicker than the image/chunk of image itself) or when the 
	* image/chunk of image is very shallow (due to the presence of a lot of processors for instance).*/
	  
	int mlim = min(yconv,ysize+lines_down-j+sy);
	int llim = min(xconv,xsize-i+sx);

	for(m=max(sy-lines_up-j,0) ; m<mlim ; m++)
		for(l=max(sx-i,0) ; l<llim ; l++)	
		{	
			//acutal convolution and renormalization	
			//image must be shifted by the amount of lines that has more than the blurring region (+lines_up)
			buffer += image[(i-sx+l)+xsize*(j-sy+m+lines_up)]*convolution_matrix[l+xconv*m];
			norm+=convolution_matrix[l+xconv*m];
		}
				
	blurred[i+xsize*j]=buffer/norm + 0.5;
}

void OMP_MPIConvolve(unsigned short int *image, unsigned short int *blurred, int xsize, int ysize,KTYPE *convolution_matrix, int xconv, int yconv, int lines_up, int lines_down)
/*
* Does the convolution of two matrices image and convolution_matrix and stores the results in blurred. Some upper or lower lines can be excluded from the convolution 
* by using the lines_up and lines_down specifiers 
*/
{
	
	//coordinates of the centre of the matrix
	int sx = xconv/2;
	int sy = yconv/2;
	
	//calculation of the bounds for i and j -> same as the comment in Border_blur();
	int y_max = max(ysize-sy+lines_down,0), y_min = min(sy-lines_up,ysize); 
	int i,j;

	//scanning of the whole image (or the part to be blurred at least): first the borders then the body 

	//BORDER CALCULATION -> MUST INCLUDE CHECKING (and BORDER EFFECT CORRECTION)
	
	#pragma omp for collapse(2) nowait 
	for(j=0; j<y_min; j++)
		for(i=0; i<xsize; i++) Border_blur(image,blurred,xsize,ysize,i,j,convolution_matrix,xconv,yconv,sx,sy,lines_up,lines_down);

	#pragma omp for collapse(2) nowait 
	for(j=y_max; j<ysize; j++)
		for(i=0; i<xsize; i++) Border_blur(image,blurred,xsize,ysize,i,j,convolution_matrix,xconv,yconv,sx,sy,lines_up,lines_down);

	#pragma omp for collapse(2) nowait 	
	for(j=y_min; j<y_max; j++)
		for(i=0; i<sx; i++) Border_blur(image,blurred,xsize,ysize,i,j,convolution_matrix,xconv,yconv,sx,sy,lines_up,lines_down);
	
#pragma omp for collapse(2) nowait 
	for(j=y_min; j<y_max; j++)
		for(i=xsize-sx; i<xsize; i++) Border_blur(image,blurred,xsize,ysize,i,j,convolution_matrix,xconv,yconv,sx,sy,lines_up,lines_down);
		
		

	//NON BORDER PART, NO CHECKS ON BOUNDARY
		
	int l,m;
	#pragma omp for collapse(2)
	for(j=y_min;j<y_max;j++)
		for(i=sx;i<xsize-sx;i++)
		{
			// buffere serves the same purpose as before: here is used instead of the natural choice of the blurred matrix itself to avoid lossy conversions from
			//floating point to unsigned integer -> this loss is minimized by doing it only once at the end. 
			KTYPE buffer = 0;

			//actual convolution, here there is never the necessity of renormalization !
			for(m=0; m<yconv; m++)						  //image must be shifted by the amount of lines that has more than the blurring region (+lines_up)
				for(l=0; l<xconv; l++)	buffer += image[(i-sx+l)+xsize*(j-sy+m+lines_up)]*convolution_matrix[l+xconv*m];
				
			blurred[i+xsize*j] = buffer + 0.5;
		}

	return;
}



